
## 命名
如果你无法想出一个合适的名字，很可能意味着代码“坏味道”​、设计有问题。这时可以思考一下：是不是一个方法里实现了太多的功能？或者类的封装内聚性不够？又或者是你对问题的理解还不够透彻，需要获取更多的信息？
#### 变量
- 变量名应该是名词，能够正确地描述业务，有表达力
#### 函数
- 函数的命名要体现做什么，而不是怎么做。
#### 类
- 实体类承载了核心业务数据和核心业务逻辑，其命名要充分体现业务语义，并在团队内达成共识，如 Customer、Bank 和 Employee 等。
- 辅助类是辅佐实体类一起完成业务逻辑的，其命名要能够通过后缀来体现功能
#### 包名
- 包名应该能够反映一组类在更高抽象层次上的联系
- 包的命名要适中，不能太抽象，也不能太具体
#### 模块名
- 模块（Module）主要是指 Maven 中的 Module，相对于包来说，模块的粒度更大，通常一个模块中包含了多个包。

#### 注释
如果注释是为了阐述代码背后的意图，那么这个注释是有用的；如果注释是为了复述代码功能，那么就要小心了，这样的注释往往意味着“坏味道”

## 规范

信息熵，就是一条信息的信息量大小和它的不确定性之间的关系。举个例子，假设消息由符号 A、C、G 和 T 组成，如果序列高度有序，例如“A A A A A A A … A”​，则熵为零。而完全随机的序列，例如“G A T A C G A … A”​，熵值达到最大。

#### 异常
##### 异常的坏处

（1）代码中到处充斥着异常捕获的 try/catch 的代码，搞乱了代码结构，把错误处理与正常流程混为一谈，严重影响了代码的可读性。

（2）异常处理不统一，有的场景对外直接抛出异常，有的场景对外返回错误码，这种不一致性让服务的调用方摸不着头脑，增加了服务的使用成本和沟通成本。
##### 为什么不Checked Exception

因为它破坏了开闭原则。如果你在一个方法中抛出了 Checked Exception，而 catch 语句在3个层级之上，那么你就要在 catch 语句和抛出异常处理之间的每个方法签名中声明该异常。这意味着在软件中修改较低层级时，都将波及较高层级，修改好的模块必须重新构建、发布，即便它们自身所关注的任何东西都没有被改动过。

这也是 C#、Python 和 Ruby 语言都不支持 Checked Exception 的原因，因为其依赖成本要高于显式声明带来的收益。

#### 错误码

错误码非常重要，一定要在系统搭建之初就制定好相应的规范，否则当系统上线后，系统的错误码已经对前端或者外部系统进行了透出，再重构的可能性就很小了。

- 编号错误码：Oracle 中总共有2000多个异常，其编码规则是 ORA-00001~ORA-02149
- 显性化错误码：
#### 埋点

“埋点”对于产品经理和运营人员了解业务运行情况非常重要，基于统计分析工具的数据处理流程：

![](../../attachments/Pasted%20image%2020240814112614.png)

## 函数

#### 优化判空

## 设计原则
#### SOLID 原则
##### Single Responsibility Principle（SRP）

SRP 要求每个软件模块职责要单一，衡量标准是模块是否只有一个被修改的原因。职责越单一，被修改的原因就越少，模块的内聚性（Cohesion）就越高，被复用的可能性就越大，也更容易被理解。

 ##### Open Close Principle（OCP）。
在面向对象设计中，我们通常通过继承和多态来实现 OCP，即封装不变部分。对于需要变化的部分，通过接口继承实现的方式来实现“开放”​。

很多的设计模式都以达到 OCP 目标为目的。例如，装饰者模式，可以在不改变被装饰对象的情况下，通过包装（Wrap）一个新类来扩展功能；策略模式，通过制定一个策略接口，让不同的策略实现成为可能；适配器模式，在不改变原有类的基础上，让其适配（Adapt）新的功能；观察者模式，可以灵活地添加或删除观察者（Listener）来扩展系统的功能。
 ##### Liskov Substitution Principle（LSP）​：里氏替换原则。
父类型都应该可以正确地被子类型替换
根据 LSP 的定义，如果在程序中出现使用 instanceof、强制类型转换或者函数覆盖，很可能意味着是对 LSP 的破坏。

##### Interface Segregation Principle（ISP）​：接口隔离原则
接口隔离原则认为不能强迫用户去依赖那些他们不使用的接口。换句话说，使用多个专门的接口比使用单一的总接口要好。

满足 ISP 之后，最大的好处是可以将外部依赖减到最少。你只需要依赖你需要的东西，这样可以降低模块之间的耦合（Couple
##### Dependency Inversion Principle（DIP）​：依赖倒置原则

高层模块不应该依赖于低层模块，二者都应该依赖于抽象。抽象不应该依赖细节，细节应该依赖抽象。

通过**注入**将具象模块关联起来

#### DRY（Dont Repeat Yourself）
#### YAGNI（You Ain’t Gonna Need It）
#### Rule of Three
DRY 原则和 YAGNI 原则是不兼容的。前者追求“抽象化”​，要求找到通用的解决方法；后者追求“快和省”​，意味着不要把精力放在抽象化上面，因为很可能“你不会需要它”​。因此，就有了 Rule of Three 原则。

三次原则指导我们可以通过以下步骤来写代码。（1）第一次用到某个功能时，写一个特定的解决方法。（2）第二次又用到的时候，复制上一次的代码。（3）第三次出现的时候，才着手“抽象化”​，写出通用的解决方法。

#### KISS（Keep It Simple and Stupid）

最早由 Robert S. Kaplan 在著名的平衡计分卡理论中提出。他认为把事情变复杂很简单，把事情变简单很复杂。好的目标不是越复杂越好，反而是越简洁越好。

#### POLA（Principle of least astonishment）

最小惊奇原则，写代码不是写侦探小说，要的是简单易懂，而不是时不时冒出个“Surprise”​。


## 设计模式

- （1）单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点，以便外部获取该实例，其拓展是有限多例模式。
- （2）原型（Prototype）模式：将一个对象作为原型，通过对其进行复制操作而复制出多个和原型类似的新实例。
- （3）工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。
- （4）抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。
- （5）建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同的需要分别创建它们，最后构建成该复杂对象。
- （6）代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问，即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。
- （7）适配器（Adapter）模式：将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
- （8）桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。
- （9）装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。
- （10）外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。
- （11）享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。
- （12）组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。
- （13）模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使子类可以在不改变该算法结构的情况下，重定义该算法的某些特定步骤。
- （14）策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。
- （15）命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。
- （16）职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式可以去除对象之间的耦合。
- （17）状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。
- （18）观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。
- （19）中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。
- （20）迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。
- （21）访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。
- （22）备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。
- （23）解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。

## DDD 的精髓

#### ORM

领域模型和数据模型并不是一一对应的关系，但也不排除，有些情况领域模型和数据模型是趋同的，但是大部分情况都需要做一层映射（Mapping）​。为了弥补二者之间的差异，行业先驱们做了很多关于映射工作的尝试，这种技术有一个名称叫作对象关系映射

ORM 的问题在于它太理想化，期望通过工具把数据建模和领域建模合一，这样的尝试注定是很难成功的。因此，Hibernate 和 JPA 的衰落是可以预见的。现在使用最多的是 MyBatis，它很简单，完全不理会复杂的关系和对象之间的复杂关系映射，只做数据库表和 DO 之间的简单映射。

复杂的数据库关系和对象关系之间的差异，其本质是数据模型和领域模型之间的差异，而这种差异的多样性和灵活性是很难通过规则预先定义的，这也是为什么工具的作用会很有限。现在的互联网大厂大多使用 MyBatis，原因也在于此。因此，如果你打算实践 DDD，请一定不要让工具帮你去建模，工具不会抽象，也不会思考，还是要老老实实自己动手去建。